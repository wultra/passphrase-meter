/*
 * Copyright 2018 Wultra s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.wultra.android.passphrasemeter;

import android.content.res.AssetManager;
import androidx.annotation.IntDef;
import androidx.annotation.NonNull;
import androidx.annotation.WorkerThread;

import com.wultra.android.passphrasemeter.exceptions.WrongPasswordException;
import com.wultra.android.passphrasemeter.exceptions.WrongPinException;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.EnumSet;

/**
 * Class that provides methods for testing strength of passwords and PINs. You cannot instantiate
 * this class, but you can use {@link #getInstance()} method to obtain its unique instance. We know
 * that the singleton patter is sometimes considered as an anti-pattern, but the underlying C "Zxcvbn"
 * implementation unfortunately allows only one instance of the dictionary used at the time.
 */
public class PasswordTester {

    static {
        System.loadLibrary("WultraPasswordTester");
    }

    // Singleton

    private static class SingletonHelper {
        private static final PasswordTester instance = new PasswordTester();
    }

    /**
     * @return Unique instance of {@link PasswordTester}
     */
    public static @NonNull PasswordTester getInstance() {
        return SingletonHelper.instance;
    }

    /**
     * Private constructor.
     */
    private PasswordTester() {}


    // Dictionary management

    /**
     * Loads dictionary file from asset manager. The previously loaded dictionary is automatically
     * released. The dictionary asset file must contain a precompiled file, generated by the
     * dictionary generator (see our library documentation for details).
     *
     * @param manager {@link AssetManager} containing dictionary
     * @param dictionaryAsset name of dictionary asset
     * @return {@code true} if dictionary was loaded successfully.
     */
    @WorkerThread
    public native boolean loadDictionary(@NonNull AssetManager manager, @NonNull String dictionaryAsset);

    /**
     * Releases resources previously allocated in {@link #loadDictionary(AssetManager, String)} method.
     * If there is no dictionary loaded, then does nothing.
     */
    public native void freeLoadedDictionary();

    /**
     * @return {@code true} if there's loaded dictionary.
     */
    public native boolean hasLoadedDictionary();

    /**
     * Tests the strength of the password. Before you test the passwords, you should load a right
     * dictionary by calling {@link #loadDictionary(AssetManager, String)} method.
     *
     * @param password Password to test
     * @return Strength of the password
     * @throws WrongPasswordException if provided password is {@code null} or cannot be converted
     *         to C-string.
     */
    public PasswordStrength testPassword(@NonNull String password) throws WrongPasswordException {

        byte[] passwordByteArray = password.getBytes(StandardCharsets.UTF_8);
        final PasswordStrength result = testPassword(passwordByteArray);
        Arrays.fill(passwordByteArray, (byte) 0);
        return result;
    }

    /**
     * Tests the strength of the password. Before you test the passwords, you should load a right
     * dictionary by calling {@link #loadDictionary(AssetManager, String)} method.
     *
     * @param passwordBytes Password to scan as byte array.
     * @return Strength of the password
     * @throws WrongPasswordException if provided password is {@code null} or cannot be converted
     *         to C-string.
     */
    public PasswordStrength testPassword(@NonNull byte[] passwordBytes) throws WrongPasswordException {

        switch (testPasswordByteJNI(passwordBytes)) {
            case PassResultCode.VERY_WEAK:
                return PasswordStrength.VERY_WEAK;
            case PassResultCode.WEAK:
                return PasswordStrength.WEAK;
            case PassResultCode.MODERATE:
                return PasswordStrength.MODERATE;
            case PassResultCode.GOOD:
                return PasswordStrength.GOOD;
            case PassResultCode.STRONG:
                return PasswordStrength.STRONG;
            case PassResultCode.WRONG_INPUT:
                throw new WrongPasswordException();
            default:
                throw new WrongPasswordException("Unknown result returned.");
        }
    }

    /**
     * Scans PIN for possible issues.
     *
     * @param pin PIN to scan.
     * @return Result of the scan.
     * @throws WrongPinException if provided PIN contains some invalid characters,
     * is too short or long (minimum length for PIN is 4 and maximum 100).
     */
    public PinTestResult testPin(@NonNull String pin) throws WrongPinException {

        byte[] pinByteArray = pin.getBytes(StandardCharsets.UTF_8);
        final PinTestResult result = testPin(pinByteArray);
        Arrays.fill(pinByteArray, (byte) 0);
        return result;
    }

    /**
     * Scans PIN for possible issues.
     *
     * @param pinBytes PIN to scan as byte array.
     * @return Result of the scan.
     * @throws WrongPinException if provided PIN contains some invalid characters,
     * is too short or long (minimum length for PIN is 4 and maximum 100).
     */
    public PinTestResult testPin(@NonNull byte[] pinBytes) throws WrongPinException {

        final @PinResultCode int result = testPinByteJNI(pinBytes);

        if ((result & PinResultCode.WRONG_INPUT_PIN) != 0) {
            throw new WrongPinException();
        }

        final EnumSet<PinTestIssue> set = EnumSet.noneOf(PinTestIssue.class);

        if ((result & PinResultCode.OK) == 0) {
            if ((result & PinResultCode.NOT_UNIQUE) != 0) {
                set.add(PinTestIssue.NOT_UNIQUE);
            }
            if ((result & PinResultCode.REPEATING_CHARACTERS) != 0) {
                set.add(PinTestIssue.REPEATING_CHARACTERS);
            }
            if ((result & PinResultCode.HAS_PATTERN) != 0) {
                set.add(PinTestIssue.HAS_PATTERN);
            }
            if ((result & PinResultCode.POSSIBLY_DATE) != 0) {
                set.add(PinTestIssue.POSSIBLY_DATE);
            }
            if ((result & PinResultCode.FREQUENTLY_USED) != 0) {
                set.add(PinTestIssue.FREQUENTLY_USED);
            }
        }

        return new PinTestResult(pinBytes.length, set);
    }

    // Private methods & constants

    /**
     * Defines constants returned from {@link #testPasswordByteJNI(byte[])} method.
     * The constants must match values from {@code WPM_PasswordResult} C enumeration.
     */
    @Retention(RetentionPolicy.SOURCE)
    @IntDef({PassResultCode.VERY_WEAK, PassResultCode.WEAK, PassResultCode.MODERATE,
             PassResultCode.GOOD, PassResultCode.STRONG, PassResultCode.WRONG_INPUT})
    private @interface PassResultCode {
        int VERY_WEAK      = 0;
        int WEAK           = 1;
        int MODERATE       = 2;
        int GOOD           = 3;
        int STRONG         = 4;
        int WRONG_INPUT    = 5;
    }

    /**
     * Defines constants returned from {@link #testPinByteJNI(byte[])} method.
     * The constants must match values from {@code WPM_PasscodeResult} C enumeration.
     */
    @Retention(RetentionPolicy.SOURCE)
    @IntDef(flag = true,
            value = {PinResultCode.OK, PinResultCode.NOT_UNIQUE, PinResultCode.REPEATING_CHARACTERS,
                     PinResultCode.HAS_PATTERN, PinResultCode.POSSIBLY_DATE,
                     PinResultCode.FREQUENTLY_USED, PinResultCode.WRONG_INPUT_PIN})
    private @interface PinResultCode {
        int OK                     = 1;
        int NOT_UNIQUE             = 1 << 1;
        int REPEATING_CHARACTERS   = 1 << 2;
        int HAS_PATTERN            = 1 << 3;
        int POSSIBLY_DATE          = 1 << 4;
        int FREQUENTLY_USED        = 1 << 5;
        int WRONG_INPUT_PIN        = 1 << 6;
    }

    /**
     * Tests the strength of the password.
     *
     * @param byteArray Password as byte array
     * @return Integer comparable to constants from {@link PassResultCode} private class.
     */
    @PassResultCode
    private native int testPasswordByteJNI(@NonNull byte[] byteArray);

    /**
     * Tests the PIN properties.
     *
     * @param byteArray PIN as byte array
     * @return Integer with combination of factors from {@link PinResultCode} private interface.
     */
    @PinResultCode
    private native int testPinByteJNI(@NonNull byte[] byteArray);
}